# ARM寄存器

对于编写一般用户程序的程序员来说，有16个寄存器是用户程序可访问的。它们可以分为通用寄存器(General Purpose Registers)和特殊寄存器(Special Purpose Registers)。

它们的统称分别是`R0-R15`，除此之外特殊寄存器也有它们自己的名称。详见下表。

|寄存器通用名称|寄存器别名|寄存器作用|
|:-:|:-:|:-:|
|R0|-|通用寄存器|
|R1|-|通用寄存器|
|R2|-|通用寄存器|
|R3|-|通用寄存器|
|R4|-|通用寄存器|
|R5|-|通用寄存器|
|R6|-|通用寄存器|
|R7|-|通用寄存器|
|R8|-|通用寄存器|
|R9|-|通用寄存器|
|R10|-|通用寄存器|
|R11|FP|帧指针(Frame Pointer)|
|R12|IP|特殊用途|
|R13|SP|栈指针(Stack Pointer)|
|R14|LR|链接寄存器(Link Register)|
|R15|PC|程序计数器(Program Counter)|
|CPSR|-|标志寄存器|

**R0-R10**：这些寄存器都是通用寄存器，可以在ARM汇编程序设计时任意使用。

为了介绍下面几个寄存器，我们需要先来了解什么是**栈**。

简单地说，在汇编语言中，栈是一块存储各函数内部数据的一块存储区域。在本教程中，假设***栈是由高地址向低地址增长的***。它具备后进先出(LIFO)的特性。如果你曾学过数据结构，你应该很明白什么是栈。

为了提供一个更简单明了的解释，在这里说一个简化的例子：

每个程序都是由函数组成的，我们可以把操作系统启动，运行程序看成一个一个函数调用。每调用一个函数，被调用函数就会将属于自己那部分的内部数据存入到栈的顶部，这样栈的大小就会增加。当一个函数运行结束后，函数会把自己的数据从栈的顶部清除，栈就变小了。

**R11(FP)**：一般来说，帧指针指向栈中当前函数内部数据的的底部。它的存在可以方便程序访问栈中的内部数据。假设FP指针处存放了一个整形数组，假定是`int arr[10]`，那么我就可以用FP加上一个偏移量`FP-36`代表`arr[9]`的地址。

**R13(SP)**：栈指针指向栈的顶部。当我们想从栈上分配空间时，要对栈指针进行减操作。从栈上回收空间时，要对栈进行加操作。假设我们要在栈上分配一个字的空间，那么我们就令`SP=SP-4`。同理回收空间时，就要`SP=SP+4`。

**R14(LR)**：链接寄存器存放调用当前函数的函数的返回地址。设想有下列C语言代码：

```cpp
void func1(){ //Line 1

}
void func2(){ //Line 4

}
int main(){ //Line 7
	func1(); // Line 8
	func2(); // Line 9
}
```

从C语言的代码抽象级别上来看，当机器执行到函数`func1()`时，`LR`寄存器中的值应是第9行所在的代码地址。原因是：当从函数`func1()`返回到`main()`时，紧接着应该执行`func2()`。

当程序中存在多重函数调用时，应当把`LR`寄存器保护起来。即在调用新函数之前，将`LR`寄存器中的返回地址存入栈中，当新函数返回后，再将`LR`寄存器的返回地址恢复。

**R15(PC)**：在ARM状态下，程序计数器始终指向当前指令+8（两条ARM指令的长度）处的地址。在Thumb状态下，程序计数器始终指向当前指令+4（两条Thumb指令的长度）处的地址。这和x86架构下PC始终指向下一条待执行的指令地址很不同。当跳转指令执行时，PC会被置为待跳转的指令地址。有趣的一点是，ARM架构的PC是可以直接由指令写的，这和x86大不相同。

**CPSR**：这个寄存器和x86中的`EFLAGS`的作用是一样的，都存放了一些程序标志。它不能够被程序设计者直接操作和使用，可以暂时不用考虑。